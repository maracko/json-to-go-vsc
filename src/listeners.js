/**
 * JSON to Go extension for VS Code.
 *
 * Date: February 2024
 * Author: Mario Petriƒçko
 * GitHub: http://github.com/maracko/json-to-go-vsc
 *
 * Apache License
 * Version 2.0, January 2004
 * http://www.apache.org/licenses/
 *
 * Depends on JSON-to-Go by mholt: https://github.com/mholt/json-to-go. Its source is included in this repo.
 */

/**********/
const { lKey, convertText, saveConversion, isComplexJSON } = require('./util');
const { keys, g, vscode, enums } = require('./globals');
const { type } = require('./types');
/**********/

/**
 * Listens for text changes in the active editor and converts the text to Go struct if the text matches the clipboard text, is valid JSON and the language is configured inside settings.
 * @param {vscode.TextDocumentChangeEvent} ev The event object.
 */
async function onDidChangeTextDocumentListener(ev) {
  let langs = g.ctx.globalState.get(lKey(keys.ctx.tmp.pasteIntegrationLangs));
  if (!langs.includes('*') && !langs.includes(ev.document.languageId)) {
    return Promise.resolve();
  }

  let clipTxt = await vscode.env.clipboard.readText();
  if (!clipTxt || !isComplexJSON(clipTxt)) return Promise.resolve();
  let struct = convertText(clipTxt);
  if (struct.error) return Promise.resolve();

  for (let change of ev.contentChanges) {
    if (change.text.length < 2 || !isComplexJSON(change.text)) continue;
    let changeStruct = convertText(change.text);
    if (!type(changeStruct.error, enums.T.undefined) || changeStruct.go !== struct.go) continue;
    if (g.ctx.globalState.get(lKey(keys.ctx.tmp.promptForStructName))) {
      let structName = await vscode.window.showInputBox({
        prompt: 'Generated Go type name',
        value: g.cfg.get(keys.settings.generatedTypeName),
      });
      structName = structName || 'AutoGenerated';
      struct = convertText(clipTxt, structName);
    }
    let edit = new vscode.WorkspaceEdit();
    let lines = change.text.split('\n');
    let replaceRange = new vscode.Range(
      change.range.start,
      new vscode.Position(
        change.range.start.line + (lines.length > 1 ? lines.length - 1 : 0),
        change.range.end.character + (lines.length > 1 ? lines[lines.length - 1].length : 0)
      )
    );
    edit.replace(ev.document.uri, replaceRange, struct.go);
    await vscode.workspace.applyEdit(edit);
    if (g.cfg.get(keys.settings.saveConversions)) await saveConversion(change.text, struct.go, { addPackage: true });
  }

  return await Promise.resolve();
}

/**
 * Listens for changes in the settings and updates the context values and listeners accordingly.
 * @param {vscode.ConfigurationChangeEvent} ev The event object.
 */
async function onDidChangeConfigurationListener(ev) {
  if (ev.affectsConfiguration(lKey(keys.settings.pasteIntegration.self))) {
    let { langs } = await updatePasteContext();
    langs.length > 0 ? await g.li.onDidChangeTextDocument.enable() : await g.li.onDidChangeTextDocument.dispose();
  }

  return Promise.resolve();
}

async function onDidChangeActiveTextEditorListener() {
  return Promise.resolve();
}

/**
 * Updates the paste integration global context with setting values
 * @returns {Promise<Object>} The current configuration values.
 */
async function updatePasteContext() {
  let ctx = {
    langs: [],
    promptForTypeName: false,
  };
  ctx.langs = g.cfg.get(keys.settings.pasteIntegration.supportedLanguages);
  ctx.promptForTypeName = g.cfg.get(keys.settings.pasteIntegration.promptForTypeName);
  await g.ctx.globalState.update(lKey(keys.ctx.tmp.pasteIntegrationLangs), ctx.langs);
  await g.ctx.globalState.update(lKey(keys.ctx.tmp.promptForStructName), ctx.promptForTypeName);
  return Promise.resolve(ctx);
}

module.exports = {
  onDidChangeActiveTextEditorListener,
  onDidChangeConfigurationListener,
  onDidChangeTextDocumentListener,
  updatePasteContext,
};
